\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[document]{ragged2e}
\usepackage[]{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[
backend=biber,
style=numeric,
sorting=none
]{biblatex}
\addbibresource{bibbilography.bib}
\usepackage[T1]{fontenc}
\usepackage{array}

\title{Assignment 1}
\author{Pratik Gaikwad (10420318)}
\date{February 2017}

\begin{document}

\maketitle

\section*{Problem 1: Conditional Probabilities}
    
   \paragraph {Question 1)} Prove \emph{Baye's Theorem}, namely that \newline
   
    
    \begin{center}
        \begin{math}
            P(A|B) = \cfrac {P(A)P(B|A)}{P(B)}
        \end{math}
    \end{center}

    \paragraph{Answer:}
        
        \begin{flushleft}
            Since intersection in probability is commutative we can write,
        \end{flushleft}
        
        \begin{center}
            \begin{math}
                A \hspace{1mm} \cap \hspace{1mm} B \hspace{1mm} = \hspace{1mm} B \hspace{1mm} \cap \hspace{1mm} A
            \end{math}
        \end{center}
    
        applying probability on both side:        
        \begin{center}
            \begin{math}
                P(A \hspace{1mm} \cap \hspace{1mm} B) \hspace{1mm} = \hspace{1mm} P(B \hspace{1mm} \cap \hspace{1mm} A)
            \end{math}
        \end{center}
    
        using definition of \emph{conditional probability} on both sides,
        
        \begin{center}
            \begin{math}
                P(A)P(B|A) = P(B)P(A|B)
            \end{math}
        \end{center}
               
        
        \begin{center}
            \begin{math}
                \therefore P(A|B) = \cfrac {P(A)P(B|A)}{P(B)}
            \end{math}
        \end{center}

    
    \paragraph {Question 2)} \(\hspace{1mm} Let \{{E_i | i=1,...,n}\}\)
    
            be events that comprise a partition of the space of all possible events
            (that is, disjoint events so that with probability 1 exactly one of them occurs). Show that for any
            event A, it holds that:
        
        \begin{center}
            \begin{math}
                P(A) = \sum_{i=1}^{n} P[A|E_i]P[E_i]
            \end{math}
        \end{center}

    \paragraph{{Answer:}} \cite{universityofedinburgh}
    
        \begin{flushleft}
            This proof is extension to proof of \emph{Baye's theorem}. Using definition of \emph{Baye's theorem}:
        \end{flushleft}
        
        \begin{center}
            \begin{math}
                p(A|E_i) = \cfrac{P(A \hspace{1mm} \cap \hspace{1mm} E_i)}{P(E_i)} = \cfrac{P(E_i|A)P(A)}{P(E_i)}
            \end{math}
        \end{center}
        
        \begin{flushleft}
            As it is assumed that 
            \(E_i \hspace{1mm} \cap \hspace{1mm} E_j = \emptyset\)
            for all \(i \neq j:\)
        \end{flushleft}
        
        \begin{eqnarray*}
            P(A) = \sum_{i=1}^{n} P(A \hspace{1mm} \cap \hspace{1mm} E_i) && (All \hspace{1mm} E_i 's \hspace{1mm} are \hspace{1mm} disjoints)\\
            P(A) = \sum_{i=1}^{n} P(A | E_i)P(E_i)
        \end{eqnarray*}
    
\section*{Problem 2: Decrypting an encrypted password}
    Assume that an attacker knows that a user’s password is either \emph{p1 = abcd} or \emph{p2 = bedg}. Say the user encrypts his password using a classical cipher, and the attacker sees the resulting ciphe-rtext \emph{c}. Show how the attacker can determine the user’s password, or explain why this is not possible, when:
    
    \paragraph {Question 1)} The shift cipher is used to produce cipher-text \emph{c}.     
    
    \paragraph{{Answer:}}
    
    \begin{flushleft}
        It \underline{is possible} for attacker to determine the password. As the cipher used is \emph{Shift Cipher}, the key space \(\mathcal{K}\) is fixed and limited to 26. i.e. 
        \(\mathit{k} \in \{0, 1,\hspace{1mm} ... \hspace{1mm}, 25\}\)
        
        The probability of \(\mathit{k}\) being selected is P(\(\mathcal{K}\) = \(\mathit{k}) = \cfrac{1}{26}\) applicable for all \(\mathit{k} \in \mathcal{K}\). As the attacker can see cipher-text \emph{c}, he needs to compute \(\mathit{c} = [\mathit{m_i + k} (mod(26))]\) where \(\mathit{i} \in \{0, 1,\hspace{1mm} ... \hspace{1mm}, 25\}\)        
    \end{flushleft}
    
    
    \paragraph {Question 2)} The Vigenére cipher is used to produce \emph{c}, using period 2, period 3, and period 4 respectively.
    
    \paragraph {Answer:}
    \begin{flushleft}
        In Vigenére cipher a keyword is used as secret key to create cipher text. The cipher text is generated by adding \emph{positions of plain text letter and corresponding key letter} respectively and then selecting letter at the \emph{position of sum}. The wrap around is done as per necessity. As the attacker knows that the password is either \emph{abcd} or \emph{bedg} he can form two equations using two respective cipher texts and plain texts as:
    \end{flushleft}
    
    \begin{center}
        \( c_1 = m_1 + \mathit{k}\) \\
        \( c_2 = m_2 + \mathit{k}\)
    \end{center}
        i.e.
    \begin{center}
        \( c_1 = abcd + \mathit{k}\) \\
        \( c_1 = bedg + \mathit{k}\)        
    \end{center}
    
    with proper permutation an attacker \underline{can determine} correct password in case of Vigenére cipher.
    
\section*{Problem 3: Breaking the substitution cipher}

    \paragraph{Question 1)} Provide a formal definition for the mono-alphabetic substitution cipher, or simply substitution cipher, by describing its message space \(\mathcal{M}\) and the algorithms \textbf{Gen, Enc} and \textbf{Dec}.
    
    \paragraph{Answer:}
        
        \begin{flushleft}
            \textbf{Message space \(\mathcal{M}\)}:\\
                All the possible message of any length such that
            \begin{center}
                \(\mathcal{M}\) = $\{0,1\}^*$ \\
            \end{center}
            \textbf{Key generation algorithm Gen}:\\
                \hspace{1cm}A probabilistic algorithm that outputs a key \(\mathit{k}\) according to some distribution This defines key space \(\mathcal{K}\) in this case 26!.\newline
            
            \textbf{An encryption algorithm Enc}:\\
                \hspace{1cm} Takes \(\mathit{k} \) as input along with message \(\mathit{m}\) and returns a cipher-text \emph{c}\\
                such that: \emph{c} = \(Enc_k(m)\)\\
                
            \textbf{A decryption algorithm Dec}:\\
                \hspace{1cm} Takes \(\mathit{k}\) as input along with cipher text \(\mathit{c}\) and returns a plain-text \(\mathit{m}\)\\
                such that: \emph{m} = \(Dec_k(c)\)\\
            
            The mono-alphabetic cipher or substitution cipher can be defined as an algorithm over \(\mathcal{M}\) which maps units of cipher-text with plain-text in a fixed manner using keys \(\mathit{k}\) generated by \textbf{Gen}.
            
        \end{flushleft}
    
    \paragraph{Question 2)} Figure 1 depicts a cipher-text \emph{c} that has been produced by a substitution cipher. How the histogram in Figure 2 can be used to successfully decrypt \emph{c} to the corresponding plain-text \emph{m}? What is \emph{m}?
    
    \paragraph{Answer:} \cite{moderncrypto}
        \begin{flushleft}
            Since substitution cipher is used, each letter in cipher-text is one to one mapped with each letter in plain-text, hence we can make use of probability distribution of letters in English language(given in histogram). Using the histogram, we can count average frequency of the letters and thus probability distribution.
            Once probability distribution is computed, we can guess the mapping based on frequency of their occurrence. For instance we know that \textbf{\emph{e}} occurs most in English language, we can safely assume that most frequent letter in the cipher-text is \textbf{\emph{e}} and so on.
            
            So the histogram and cipher-text can be converted to their frequency table as:
        \end{flushleft}
        
        \begin{center}
            \begin{tabular}{ | m{3cm} | m{3cm}| m{3cm} | } 
              \hline
              English Letter & Ciphered Letter & Frequncy \\ 
              \hline
              E & F & 37 \\ 
              \hline
              T & Q & 26 \\ 
              \hline
              A & W & 21 \\
              \hline
              O & G & 19 \\
              \hline
              I & L & 17 \\
              \hline
              N & O & 16 \\
              \hline
              S & V & 15 \\
              \hline
              H & H & 14 \\
              \hline
              R & B & 12 \\
              \hline
              D & P & 10 \\
              \hline
              L & I & 9 \\
              \hline
              C & J & 9 \\
              \hline
              U & Z & 7 \\
              \hline
              M & R & 7 \\
              \hline
              W & M & 4 \\
              \hline
              F & E & 4 \\
              \hline
              G & Y & 3 \\
              \hline
              Y & C & 3 \\
              \hline
              P & K & 3 \\
              \hline
              B & A & 3 \\
              \hline
              V & D & 2 \\
              \hline
              K & S & 2 \\
              \hline
              J & X & 1 \\
              \hline
              X & U & 0 \\
              \hline
              Q & T & 0 \\
              \hline
              Z & N & 0 \\
              \hline
            \end{tabular}
        \end{center}
    
    \begin{flushleft}
        With the help of above table the first line of the cipher-text can be decoded into plain-text as: 
        \(\mathcal{CRYPTOGRAPHIC SYSTEMS ARE EXTREMELY DIFFICULT TO BUILD}\)
        Continuing in this way, we can decode entire plain-text \(\mathit{m}\).
    \end{flushleft}
    
    \paragraph{Question 3)} Show that the substitution cipher is trivial to break when the adversary launches a \emph{chosen-plain-text} attack. How much chosen plain-text is needed to recover the entire secret key? What is the shortest chosen single-message plain-text that you can find, which is a valid English message and would successfully recover the key?
    
    \paragraph{Answer:}
        \begin{flushleft}
            It is possible to break text encrypted substitution cipher. If we can get cipher-text of distinct 25 letters from \emph{chosen-plain-text}, we can fully recover key used to encrypt the text. And thus using minimum distinct 25 letters from \emph{chosen-plain-text} we can completely decipher plain-text.
            Hence if an adversary selects distinct 25 distinct letters carefully, using permuatation he can easily decipher key and then message.
            
            A pangram sentence(which contains every alphabet at least once)\cite{pangram} should be sufficient to break the cipher-text. \\
            As an example, \emph{The quick brown fox jumps over the lazy dog} which makes sense, can be chosen as start to break cipher.
        \end{flushleft}
    
\section*{Problem 4: Perfecting the imperfect ciphers}
    
    Describe under which \emph{conditions}, if any, and why, the following classic ciphers are perfectly secret:
    
    \paragraph{Question 1)} The mono-alphabetic substitution cipher.
    \paragraph{Answer:} 
        \begin{flushleft}
            The mono-alphabetic substitution cipher can be perfectly secure if:\\
            1) Key space \(\mathcal{K}\) exactly same as message space \(\mathcal{M}\). \\
            2) The selection of key \(\mathit{k}\) is truly random from \(\mathcal{K}\).
            
            The above two assumption holds because: \(Pr[Enc_k(m1)=c]=Pr[Enc_k(m2)=c]\)
        \end{flushleft}
    
    \paragraph{Question 2)} The Vigenére cipher
    \paragraph{Answer:}
        \begin{flushleft}
            The Vigenére cipher can be perfectly secure if:\\
            1) Key length \(\mathit{k}\) must be at least as long as the message \(\mathit{m}\). \\
            2) The each selected letter of key \(\mathit{k}\) must be selected independently and uniformly at random from ciphered letter \(\mathit{c}\). \\
            3) The same key must not be used for more than one message i.e. Key space \(\mathcal{K}\) exactly same as message space \(\mathcal{M}\).
        \end{flushleft}
        
\section*{Problem 5: Proving or refuting perfect secrecy}
    \paragraph{Question 1} Consider the extension of the One-time Pad cipher, where a cipher-text \emph{c} is possibly longer than the plain-text \emph{m} (and the key \emph{k}) by one bit, namely, by having the encryption algorithm \textbf{Enc} appending to \(m \oplus k\), either a 0 with probability 0.65 or a 1 with probability 0.3. Is this extension a perfectly secret cipher and why?
    
    \paragraph{Answer:}
        \begin{flushleft}
            The extension of One-time pad is perfectly secure cipher. Since it is given |\emph{c}| > |\emph{m}| and |\emph{c}| > |\emph{k}| we can conclude |\(\mathcal{M}\)| = |\(\mathcal{K}\)|.
        \end{flushleft}
        
        \begin{center}
            \(Enc = \mathit{m} \oplus \mathit{k} \) \\
            $\Rightarrow$ \(c = \mathit{m} \oplus \mathit{k} \)
        \end{center}
        
        \begin{flushleft}
            It is given that P[\(\mathcal{C}\) = 0] = 0.65 and P[\(\mathcal{C}\) = 1] = 0.3, we assume an integer \emph{i} > 0 such that:
        \end{flushleft}
        
        \begin{center}
            \(\mathit{m},\mathit{c}, \mathit{k}\{ 0,1\}^\mathit{i}\)
        \end{center}
        
        \begin{flushleft}
            With the definition of perfectly secure theorem \\
            \(
                P[\mathcal{C} = \mathit{c} | \mathcal{M} = \mathit{m}] = 
                P[\mathcal{M} \oplus \mathcal{K} = \mathit{c} | \mathcal{M} = \mathit{m}] = 
                P[\mathit{m} \oplus \mathcal{K} = \mathit{c}] =
            \) \\ 
            \(P[\mathcal{K} = \mathit{m} \oplus \mathit{c}] = \cfrac{1}{2^\mathit{i}}\)
            
            Thus this extension is secure since \(P[\mathcal{C}=1] = 0.3 < \cfrac{1}{2^\mathit{i}}\)

        \end{flushleft}
        
        
    \paragraph{Question 2}Based on your answer in the previous question, prove or refute the following statement: An encryption scheme with message space \(\mathcal{M}\) is perfectly secret if and only if for every probability distribution \(\mathcal{D_\mathit{m}}\) over \(\mathcal{M}\) and every \(\mathit{c_0}, \mathit{c_1} \in C\) we have,
    \begin{center}
        \(P[\mathcal{C}=\mathit{c_0}] = P[\mathcal{C}=\mathit{c_1}]\)
    \end{center}
    
    \paragraph{Answer:} using definition 4 of perfect secrecy in\cite{persecdef4}
        \begin{flushleft}
            The given statement holds true if only if the probability distribution is \textbf{\emph{uniform}} over \(\mathcal{M}\). For refuting the statement we can consider the example of non-uniform probability distribution given in the above question. i.e. P[\(\mathcal{C}\) = 0] = 0.65 and P[\(\mathcal{C}\) = 1] = 0.3.
        \end{flushleft}
        \begin{center}
            \(P[\mathcal{C}=c_0|\mathcal{M}=m] = P[\mathcal{C}=c_0] \neq P[\mathcal{C}=c_1|\mathcal{M}=m] = P[\mathcal{C}=c_1]\)
        \end{center}
        \begin{flushleft}
            Since the probability distribution is non-uniform, the given statement doesn't hold.
        \end{flushleft}
    
    
    \paragraph{Question 3:}Consider the following encryption scheme. The message space is
        \begin{center}
            \(\mathcal{M} = \{\mathit{m} \in \{0,1\}^\mathit{l} |\) the last bit of \(\mathit{m}\) is \(0\}\),
        \end{center}
        \begin{flushleft}
            algorithm \textbf{Gen} chooses a uniform key from \(\{0,1\}^\mathit{l-1}\), algorithm \(Enc_\mathit{k}(\emph{m})\) returns cipher-text \(\mathit{m} \oplus (\mathit{k}||0) \), and algorithm \(Dec_\mathit{k}(\emph{c})\) returns cipher-text \(\mathit{c} \oplus (\mathit{k}||0) \). Is this perfectly secure cipher and why?
        \end{flushleft}
        
    \paragraph{Answer:}
        \begin{flushleft}
            It is given that
        \end{flushleft}
        
        \begin{center}
            \(\mathcal{M} = \{\mathit{m} \in \{0,1\}^\mathit{l} |\) the last bit of \(\mathit{m}\) is \(0\}\),
        \end{center}
        
        \begin{flushleft}
            For the One-time pad using a fixed integer \emph{l} > 0, \\ we assume that
            \emph{l} - 1 > 0 $\Rightarrow$ \emph{l} > 1.\\
            This key sapce \(\mathcal{K}\) is given by \(\{0,1\}^\emph{l-1}\)
            This gives us 
        \end{flushleft}
        
        \begin{center}
            \(|\mathcal{M}| = |\mathcal{C}| = \mathit{l}\) \\
            \(|\mathcal{K}| = \mathit{l}-1\)
        \end{center}
        
        \begin{flushleft}
            As it is given that last bit of message is 0, length of key is \emph{l-1} and thus \(\mathcal{K} > \mathcal{M}\). Using uniform distribution over \(\mathcal{K}\) each key is chosen with equal probability of \(\cfrac{1}{2^\mathit{l-1}}\).\\
            
            And hence this encryption is \textbf{Perfectly secure}.
        \end{flushleft}
    
    
    \paragraph{Quesion 4:} When the One-time Pad encryption algorithm runs with the all-zero key \(\mathit{k} = 0^\mathit{l}\), the resulted cipher-text \emph{c} equals the plain-text \emph{m}. Consider the extension that purposely avoids this situation by disallowing \textbf{Gen} choosing the all-zero key—that is, \emph{k} is chosen uniformly at random from the set of \emph{nonzero} binary strings of length \emph{l}. Is this extension a perfectly secret cipher and why?
    
    \paragraph{Answer:}
    
    \begin{flushleft}
        Since the \textbf{Gen} is disallowed to select key with all 0's i.e. the keyspace \(\mathcal{K}\) = \(\mathcal{M}\). 
        it must select \emph{k} uniformly at random from \(\mathcal{K}\). Thus there is no information revealed about the plain-text from the cipher-text since all the bits of the plain-text will be encrypted by One-time. The length of cipher-text will be equal to or greater than length of plain-text depending on the \(|\mathit{k}|\). Since One-time pad algorithm is used we can safely assume that \(\mathit{l}\) is sufficiently large enough to avoid repetition of keys.
        And as all the conditions mentioned in definition of perfectly secure cipher are fullfilled, the given extension \textbf{generates} perfectly secure cipher.
    \end{flushleft}
    
    
\printbibliography[title={References}]
    

\end{document}
